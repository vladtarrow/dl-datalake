from datetime import UTC, datetime

import polars as pl


def test_storage_partitioning_and_boundaries(temp_datalake, sample_ohlc_generator):
    """
    Use Case 2: Storage Integrity & Use Case 12: Timezones/Boundaries
    Verifies data is correctly partitioned by date and handles day boundaries.
    """
    writer = temp_datalake["writer"]
    exchange = "TEST_EX"
    market = "SPOT"
    symbol = "TEST_SYM"

    # Generate data spanning across a day boundary
    # Start at 2023-01-01 23:50:00 UTC
    # Should result in 10 candles in 2023-01-01 and 10 in 2023-01-02
    start_ts = datetime(2023, 1, 1, 23, 50, 0, tzinfo=UTC).timestamp() * 1000
    df = sample_ohlc_generator(length=20, start_time=start_ts, period_ms=60000)

    paths = list(writer.write_ohlc(df, exchange, market, symbol))

    # Should yield 2 paths (one for each day)
    assert len(paths) == 2

    path_strs = [str(p) for p, _, _ in paths]
    # Check folder structure for 2023/01/01
    assert any("2023" in p and "01" in p and "01" in p for p in path_strs)
    # Check folder structure for 2023/01/02
    assert any("2023" in p and "01" in p and "02" in p for p in path_strs)

    # Verify content of the first file (2023-01-01)
    p1 = next(p for p, _, _ in paths if "20230101" in p.name)
    df1 = pl.read_parquet(p1)
    # Expected: 23:50 to 23:59 -> 10 rows
    assert df1.height == 10

    # Verify content of the second file (2023-01-02)
    p2 = next(p for p, _, _ in paths if "20230102" in p.name)
    df2 = pl.read_parquet(p2)
    # Expected: 00:00 to 00:09 -> 10 rows
    assert df2.height == 10


def test_cross_platform_paths(temp_datalake, sample_ohlc_generator):
    """
    Use Case 9.1: Cross-platform paths.
    Verifies that paths generated by writer are usable regardless of separator.
    (Note: python pathlib handles this mostly, but we verify writer logic).
    """
    writer = temp_datalake["writer"]
    df = sample_ohlc_generator(length=10)

    # Force some mixed separators in input args if possible?
    # Actually, main concern is if the CODE manually joins strings with '\\' or '/'
    # The writer uses pathlib, so it should be safe.
    # We verify that the output path is valid absolute path.

    paths = list(writer.write_ohlc(df, "EX", "MKT", "SYM"))
    path, _, _ = paths[0]

    assert path.is_absolute()
    assert path.exists()

    # Verify we can resolve it relative to data root
    data_root = temp_datalake["data_root"]

    # Attempt to use forward slashes manually to find the file (simulating Linux logic on Windows)
    # This checks if the directory structure implies strict names that might contain separators (bad)
    rel_path = path.relative_to(data_root)
    assert len(rel_path.parts) > 3  # e.g. EX/MKT/SYM/raw/1min/YYYY/MM/DD/file.parquet
